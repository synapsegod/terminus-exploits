local ContentProvider = game:GetService("ContentProvider")
local VirtualUserService = game:GetService("VirtualUser")
local VirtualInputService = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local PlayerService = game:GetService("Players")
local Me = PlayerService.LocalPlayer
local Camera = workspace.CurrentCamera

local Terminus = shared.Terminus or loadstring(game:HttpGet("https://raw.githubusercontent.com/synapsegod/terminus/main/main.lua"))() --require(game.ReplicatedFirst.ModuleScript)-- 
local MyStyle = Terminus:newStyle({
	ActiveColor = Color3.fromRGB(85, 170, 127),
})
local SwitchStyle = MyStyle:Clone()
SwitchStyle.BackgroundColor = Color3.fromRGB(50, 50, 50)

local Terminal = Terminus:new("VoxlbladeFarm", {Style = MyStyle})

local function GetAllEnemies()
	local interactables = workspace:WaitForChild("Interactables")
	local enemies = {}

	for _, npc in pairs (game.ReplicatedStorage:WaitForChild("NPCs"):GetChildren()) do
		if interactables:FindFirstChild(npc.Name) then continue end

		table.insert(enemies, npc.Name)
	end

	return enemies
end

local Scroll = Instance.new("ScrollingFrame")
Scroll.BackgroundTransparency = 1
Scroll.Size = UDim2.new(1, 0, 1, 0)
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.ScrollBarThickness = 4
Scroll.Parent = Terminal.Window

local Sorter = Instance.new("UIListLayout", Scroll)
Sorter.SortOrder = Enum.SortOrder.LayoutOrder
Sorter.FillDirection = Enum.FillDirection.Vertical
Sorter.HorizontalAlignment = Enum.HorizontalAlignment.Center
Sorter.VerticalAlignment = Enum.VerticalAlignment.Top
Sorter.Padding = UDim.new(0, 5)

--STATIC
local MONSTERS = GetAllEnemies()
local SAFE_ANIMATIONS = {"Stun1", "Stun2", "Stun3", "Walk", "Idle", "Buff", "Jab", "Headbutt"}
local ENCHANTMENTS = {"Legendary", "Magical", "Corrupt", "Bloody"}

--CHANGABLE BY GUI
local WHITELIST = {}
local USE_ART = true
local USE_RUNE = true
local HEIGHT = 10
local SPECIAL = true
local SPECIALS = {"Magical", "Legendary", "Corrupt", "Bloody"}
local MAX_DISTANCE = 1500
local PREVENT_AFK = true
local EVADE = true
local BLOCKONEVADE = false
local EVADE_HEIGHT = 15
local AUTO_CLICK = true
local AUTO_ATTACK = true
local EVADE_DISTANCE = 30
local RUNNING = false
local PRINT = false
local EVADING = false
local LAST_EVADE = tick()

local Connections = {}

local function getClosestNPC()
	local npcs = {}

	for _, npc in pairs (workspace:WaitForChild("NPCS"):GetChildren()) do
		if Me:DistanceFromCharacter(npc.Position) > MAX_DISTANCE then continue end

		local humanoid = npc:FindFirstChild("Humanoid", true)
		if not humanoid or humanoid.Health <= 0 then continue end

		local found = false
		if #WHITELIST == 0 then
			found = true
		else
			for _, white in pairs (WHITELIST) do
				if string.find(string.lower(npc.Name), string.lower(white)) then
					found = true
					break
				end
			end

			if SPECIAL then
				for _, special in pairs (SPECIALS) do
					local particle = npc:FindFirstChild(special)
					if particle and particle.Enabled then
						found = true
						break
					end
				end
			end
		end

		if found then
			table.insert(npcs, npc)
		end
	end

	table.sort(npcs, function(a, b)
		return Me:DistanceFromCharacter(a.Position) < Me:DistanceFromCharacter(b.Position)
	end)

	return npcs[1]
end

local function adjustRotation(root, bodyAngular)
	bodyAngular.AngularVelocity = Vector3.new(0, 2, 0)
	while root.Rotation.Y > 2 or root.Rotation.Y < -2 do
		RunService.Stepped:Wait()
	end

	bodyAngular.AngularVelocity = Vector3.new(-2, 0, 0)
	while root.Rotation.X > -88 or root.Rotation.X < -92 do
		RunService.Stepped:Wait()
	end
	bodyAngular.AngularVelocity = Vector3.new(0, 0, 0)
end

local function calculateAbove(npc)
	return npc.Position + Vector3.new(0, HEIGHT, 0)
end

local function onCharacter(character)
	wait(1)

	local root = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")
	local torso = character:WaitForChild("Torso")
	local head = character:WaitForChild("Head")

	for _, part in pairs (character:GetChildren()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
		end
	end

	local attachment = Instance.new("Part", Camera)
	attachment.Name = "MOVER"
	attachment.Size = Vector3.new(0.2, 0.2, 0.2)
	attachment.CanCollide = false
	attachment.CFrame = root.CFrame
	attachment.Transparency = 1

	local weld = Instance.new("Weld", attachment)
	weld.Part0 = attachment
	weld.Part1 = root
	weld.Enabled = true

	local bodyPosition = Instance.new("BodyPosition")
	bodyPosition.Name = "BPOSITION"
	bodyPosition.D = 500
	bodyPosition.Position = attachment.Position
	bodyPosition.MaxForce = Vector3.new(0, 0, 0)
	bodyPosition.Parent = attachment

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Name = "BVEL"
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.MaxForce = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = attachment

	local bodyAngular = Instance.new("BodyAngularVelocity")
	bodyAngular.Name = "BVELA"
	bodyAngular.AngularVelocity = Vector3.new(0, 0, 0)
	bodyAngular.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
	bodyAngular.Parent = attachment

	local weaponSlot = Me.PlayerGui:WaitForChild("Core"):WaitForChild("MainBar"):WaitForChild("WeaponArt"):WaitForChild("Cooldown")
	local runeSlot = Me.PlayerGui:WaitForChild("Core"):WaitForChild("MainBar"):WaitForChild("Rune"):WaitForChild("Cooldown")

	local collisionSignal = nil
	collisionSignal = RunService.Stepped:Connect(function()
		if not head.Parent or not torso.Parent or not attachment.Parent then
			collisionSignal:Disconnect()
			return
		end

		torso.CanCollide = false
		head.CanCollide = false
	end)

	root.ChildAdded:Connect(function(child)
		if not RUNNING then return end

		if child.ClassName == "BodyVelocity" then
			child.MaxForce = Vector3.new(0, 0, 0)
		end
	end)

	character.AncestryChanged:Connect(function(_, parent)
		if not parent then
			attachment:Destroy()
		end
	end)

	VirtualInputService:SendKeyEvent(true, Enum.KeyCode.One, false, nil)
	wait(0.1)
	VirtualInputService:SendKeyEvent(false, Enum.KeyCode.One, false, nil)

	local function loop()
		local target = getClosestNPC()
		if not target then
			wait(0.5)

			if PRINT then
				print("Waiting for target")
			end

			return
		end
		local distance = Me:DistanceFromCharacter(target.Position)

		if PRINT then
			print("NPC:", target.Name, "Distance:", distance)
		end

		bodyPosition.MaxForce = Vector3.new(0, 0, 0)
		bodyVelocity.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)

		--Move towards
		local duration = distance / 40
		local startMoving = tick()
		while target.Parent and character.Parent and attachment.Parent and RUNNING do
			RunService.Stepped:Wait()

			if tick() - startMoving >= duration + 5 then
				break
			end
			local targetPosition = calculateAbove(target)

			bodyVelocity.Velocity = (root.Position - targetPosition).Unit * -40

			local distance = Me:DistanceFromCharacter(targetPosition)
			if distance <= 5 then break end
		end

		if not target.Parent or not character.Parent then return end
		if (root.Position - calculateAbove(target)).Magnitude > 10 then return end

		bodyVelocity.MaxForce = Vector3.new(0, 0, 0)
		bodyPosition.Position = root.Position + Vector3.new(0, EVADE_HEIGHT, 0)
		bodyPosition.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)

		--Stay above and kill

		task.spawn(function()
			adjustRotation(root, bodyAngular)
		end)

		local startAttacking = tick()
		while target.Parent and character.Parent and attachment.Parent and RUNNING do
			RunService.Stepped:Wait()

			local targetPosition = calculateAbove(target)
			if EVADING then
				bodyPosition.Position = targetPosition + Vector3.new(0, EVADE_HEIGHT, 0)
			else
				bodyPosition.Position = targetPosition
			end

			if tick() - startAttacking > 25 then
				bodyPosition.Position = targetPosition + Vector3.new(0, EVADE_HEIGHT, 0)
				startAttacking = tick()

				task.spawn(function()
					adjustRotation(root, bodyAngular)
				end)
			end

			if AUTO_ATTACK == false or Terminal:IsMouseOnTop() then continue end

			if USE_ART and weaponSlot.Visible == false then
				VirtualInputService:SendKeyEvent(true, Enum.KeyCode.Q, false, nil)
				wait(0.1)
				VirtualInputService:SendKeyEvent(false, Enum.KeyCode.Q, false, nil)
			elseif USE_RUNE and runeSlot.Visible == false then
				VirtualInputService:SendKeyEvent(true, Enum.KeyCode.R, false, nil)
				wait(0.1)
				VirtualInputService:SendKeyEvent(false, Enum.KeyCode.R, false, nil)
			elseif AUTO_CLICK then
				VirtualInputService:SendMouseButtonEvent(100, 100, 0, true, game, 0)
				wait(0.05)
				VirtualInputService:SendMouseButtonEvent(100, 100, 0, false, game, 0)
			end
		end
	end

	while character.Parent and attachment.Parent do
		RunService.Stepped:Wait()

		local bool, arg = pcall(function()
			loop()
		end)
		if not bool then
			if PRINT then
				warn(arg)
			end
			wait(0.5)
		end

		RunService.Stepped:Wait()
	end
end

function Terminal:OnClose()
	RUNNING = false

	for _, connection in pairs (Connections) do
		connection:Disconnect()
	end
end

Terminal:CreateTextLabel(Scroll, {Style = MyStyle, Text = "Voxlblade Autofarm v1"})

--TARGETING------------------------------------------------------------------------

Terminal:CreateLine(Scroll, {
	Style = MyStyle,
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateTextLabel(Scroll, {
	Style = MyStyle,
	Text = "TARGETING"
})

Terminal:CreateDropdown(Scroll, {
	Style = MyStyle,
	Items = MONSTERS,
	Selected = WHITELIST,
	MultiSelect = true,
	CloseOnSelect = false,
	MaxDisplay = 10 * 20,
	Title = #WHITELIST == 0 and "Filter, none selected = all" or table.concat(WHITELIST, ", "),
	OnSelected = function(self, value)
		self.Title = #self.Selected == 0 and "Filter, none selected = all" or table.concat(self.Selected, ", ")
	end,
	OnToggleDone = function(self, value)
		Scroll.CanvasSize = UDim2.new(0, Sorter.AbsoluteContentSize.X, 0, Sorter.AbsoluteContentSize.Y)
	end,
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(Scroll, {
			Style = MyStyle,
			Text = "Include special mobs"
		}),
		Terminal:CreateSwitch(Scroll, {
			Style = SwitchStyle,
			State = SPECIAL,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				SPECIAL = state
			end,
		})
	}
})

Terminal:CreateDropdown(Scroll, {
	Style = MyStyle,
	Items = ENCHANTMENTS,
	Selected = SPECIALS,
	MultiSelect = true,
	CloseOnSelect = false,
	MaxDisplay = 4 * 20,
	Title = #SPECIALS == 0 and "No specials selected" or table.concat(SPECIALS, ", "),
	OnSelected = function(self, value)
		self.Title = #self.Selected == 0 and "No specials selected" or table.concat(self.Selected, ", ")
	end,
	OnToggleDone = function(self, value)
		Scroll.CanvasSize = UDim2.new(0, Sorter.AbsoluteContentSize.X, 0, Sorter.AbsoluteContentSize.Y)
	end,
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Maximum distance"
		}),
		Terminal:CreateTextField(nil, {
			Style = MyStyle,
			Text = tostring(MAX_DISTANCE),
			NumbersOnly = true,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, value)
				MAX_DISTANCE = tonumber(value)
			end,
		})
	}
})

--ATTACKING------------------------------------------------------------------------

Terminal:CreateLine(Scroll, {
	Style = MyStyle,
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateTextLabel(Scroll, {
	Style = MyStyle,
	Text = "ATTACKING"
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Auto attack"
		}),
		Terminal:CreateSwitch(Scroll, {
			Style = SwitchStyle,
			State = AUTO_ATTACK,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				AUTO_ATTACK = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Auto click"
		}),
		Terminal:CreateSwitch(Scroll, {
			Style = SwitchStyle,
			State = AUTO_CLICK,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				AUTO_CLICK = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Use Weapon Art"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			State = USE_ART,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				USE_ART = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Use Rune"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			State = USE_RUNE,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				USE_RUNE = state
			end,
		})
	}
})

local heightLabel = Terminal:CreateTextLabel(Scroll, {
	Style = MyStyle,
	Text = "Height above enemy " .. tostring(HEIGHT) 
})

Terminal:CreateSlider(Scroll, {
	Style = MyStyle,
	Minimum = 0,
	Maximum = 15,
	Value = HEIGHT,
	AnchorPoint = Vector2.new(0.5, 0.5),
	Position = UDim2.new(0.5, 0, 0.5, 0),
	Size = UDim2.new(1, -20, 0, 20),
	OnChanged = function(self, value)
		HEIGHT = value
		heightLabel.Text = "Height above enemy " .. tostring(value) 
	end,
})

--EVADING------------------------------------------------------------------------

Terminal:CreateLine(Scroll, {
	Style = MyStyle,
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateTextLabel(Scroll, {
	Style = MyStyle,
	Text = "EVADING"
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Evade attacks"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			State = EVADE,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				EVADE = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Block when evading"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			State = BLOCKONEVADE,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				BLOCKONEVADE = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Evade height"
		}),
		Terminal:CreateTextField(nil, {
			Style = MyStyle,
			Text = tostring(EVADE_HEIGHT),
			NumbersOnly = true,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, value)
				EVADE_HEIGHT = tonumber(value)
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Evade detection"
		}),
		Terminal:CreateTextField(nil, {
			Style = MyStyle,
			Text = tostring(EVADE_DISTANCE),
			NumbersOnly = true,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, value)
				EVADE_DISTANCE = tonumber(value)
			end,
		})
	}
})

Terminal:CreateLine(Scroll, {
	Style = MyStyle,
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Prevent AFK-kick"
		}),
		Terminal:CreateSwitch(Scroll, {
			Style = SwitchStyle,
			State = PREVENT_AFK,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				PREVENT_AFK = state
			end,
		})
	}
})

Terminal:CreateRow(Scroll, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Debug"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			State = PRINT,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				PRINT = state
			end,
		})
	}
})

Terminal:CreateTextButton(Scroll, {
	Style = MyStyle,
	Text = RUNNING and "Stop" or "Start",
	Selectable = true,
	OnSelected = function(self, state)
		RUNNING = state
		self.Text = state and "Stop" or "Start"
		if Me.Character then
			if RUNNING then
				onCharacter(Me.Character)
			else
				local attachment = Camera:FindFirstChild("MOVER")
				if attachment then attachment:Destroy() end
			end
		end
	end,
})

Scroll.CanvasSize = UDim2.new(0, Sorter.AbsoluteContentSize.X, 0, Sorter.AbsoluteContentSize.Y)

table.insert(Connections, Me.Idled:Connect(function()
	if not PREVENT_AFK then return end

	VirtualUserService:CaptureController()
	RunService.Stepped:Wait()
	VirtualUserService:ClickButton2(Vector2.new(0, 0))
end))

table.insert(Connections, Me.CharacterAdded:Connect(function(character)
	if not RUNNING then return end

	onCharacter(character)
end))

local function evade(duration)
	local last = tick()
	EVADING = true
	LAST_EVADE = last
	if BLOCKONEVADE then
		VirtualInputService:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
	end

	wait(duration)

	if LAST_EVADE == last then
		EVADING = false
		if BLOCKONEVADE then
			VirtualInputService:SendKeyEvent(false, Enum.KeyCode.F, false, nil)
		end
	end
end

local function onNPC(npc)
	wait(1)

	local animator = npc:WaitForChild("LinkedModel"):WaitForChild("Humanoid"):WaitForChild("Animator")

	task.spawn(function()
		local animationsFolder = npc:WaitForChild("Animations")
		ContentProvider:PreloadAsync(animationsFolder:GetChildren())
	end)

	animator.AnimationPlayed:Connect(function(track)
		if not RUNNING or not EVADE then return end
		if Me:DistanceFromCharacter(npc.Position) >= EVADE_DISTANCE then return end
		if table.find(SAFE_ANIMATIONS, track.Name) then return end

		if PRINT then
			print("Evading", npc.Name, track.Name)
		end

		evade(track.Length * track.Speed)
	end)

	if string.find(string.lower(npc.Name), "bomber") then
		npc.ChildAdded:Connect(function(child)
			wait(0.5)
			if child.ClassName == "Sound" and child.Name == "Bomber" then
				evade(5)
			end
		end)
	end
end

table.insert(Connections, workspace:WaitForChild("NPCS").ChildAdded:Connect(onNPC))

Terminal:Toggle(true)

for _, npc in pairs (workspace:WaitForChild("NPCS"):GetChildren()) do
	task.spawn(function()
		onNPC(npc)
	end)
end
