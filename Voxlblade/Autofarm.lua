local ContentProvider = game:GetService("ContentProvider")
local VirtualUserService = game:GetService("VirtualUser")
local VirtualInputService = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local PlayerService = game:GetService("Players")
local Me = PlayerService.LocalPlayer
local Camera = workspace.CurrentCamera

--Static
local SortModes = {"Distance", "Health", "Selection", "Enchantment"}
local Enchantments = {"Legendary", "Magical", "Corrupt", "Bloody"}
local SafeAnimations = {"Stun1", "Stun2", "Stun3", "Walk", "Idle", "Buff", "Jab"}
local Inns = {
	"Gshojpi", --Tundra
	"Gurulg", --Swamp
}

--Dynamic
local IsRunning = false
local IsEvading = false
local LastEvade = tick()
local Connections = {}

local Settings = {
	--Targeting
	Whitelist = {},
	Enchantments = table.clone(Enchantments),
	SortMode = SortModes[1],
	Height = 10,
	MaxDistance = 1500,

	--Evasion
	Evade = true,
	BlockOnEvade = false,
	EvadeHeight = 15,

	--Combat
	AutoAttack = true,
	UseWeapon = true,
	UseArt = true,
	UseRune = true,
	
	HealAtInn = false,
}

local Terminus = RunService:IsStudio() and require(game.ReplicatedFirst.Terminus) or (shared.Terminus or loadstring(game:HttpGet("https://raw.githubusercontent.com/synapsegod/terminus/main/main.lua"))())

local MyStyle = Terminus:CreateStyle({
	ActiveColor = Color3.fromRGB(85, 170, 127)
})
local SwitchStyle = MyStyle:Clone({
	BackgroundColor = Color3.fromRGB(50, 50, 50)
})

local Terminal = Terminus:new("VoxlFarm", {
	Style = MyStyle,
	ScrollContent = true
})

for k, v in pairs (Terminal:ImportSettings()) do
	Settings[k] = v
end

function Terminal:OnClose()
	IsRunning = false
	for _, connection in pairs (Connections) do
		connection:Disconnect()
	end
	table.clear(Connections)
end

local function GetActiveEnchantment(npc)
	for _, enchantment in pairs (Enchantments) do
		local particles = npc:FindFirstChild(enchantment)
		if particles and particles.Enabled then return enchantment end
	end
end

local function ClickButton(button)
	local position = button.AbsolutePosition
	local size = button.AbsoluteSize
	local center = position + (size / 2)

	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, true, game, 0)
	RunService.Stepped:Wait()
	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, false, game, 0)
end

local function GetAllEnemies()
	if RunService:IsStudio() then
		return {"Monster1", "Monster2", "Monster3", "Monster4"}
	end

	local interactables = workspace:WaitForChild("Interactables")
	local enemies = {}

	for _, npc in pairs (game.ReplicatedStorage:WaitForChild("NPCs"):GetChildren()) do
		if interactables:FindFirstChild(npc.Name) then continue end

		table.insert(enemies, npc.Name)
	end

	return enemies
end

local SortFunctions = {}
SortFunctions.Distance = function(a, b)
	return Me:DistanceFromCharacter(a.Position) < Me:DistanceFromCharacter(b.Position)
end

SortFunctions.Health = function(a, b)
	local humanoid1 = a:FindFirstChild("Humanoid", true)
	local humanoid2 = b:FindFirstChild("Humanoid", true)
	
	if humanoid1 and humanoid2 then return humanoid1.Health < humanoid2.Health end
	if humanoid1 and not humanoid2 then return true end
	if not humanoid1 and humanoid2 then return false end

	return SortFunctions.Distance(a, b)
end

SortFunctions.Selection = function(a, b)
	local index1 = nil
	local index2 = nil
	
	for i, item in pairs (Settings.Whitelist) do
		if string.find(a.Name, item) then index1 = i end
		if string.find(b.Name, item) then index2 = i end
	end
	
	if index1 and index2 then return index1 < index2 end
	if index1 and not index2 then return true end
	if not index1 and index2 then return false end
	
	return SortFunctions.Distance(a, b)
end

SortFunctions.Enchantment = function(a, b)
	local enchantment1 = GetActiveEnchantment(a)
	local enchantment2 = GetActiveEnchantment(b)
	
	if enchantment1 and enchantment2 then
		local index1 = table.find(Settings.Enchantments, enchantment1)
		local index2 = table.find(Settings.Enchantments, enchantment2)
		
		if index1 and index2 then return index1 < index2 end
		if index1 and not index2 then return true end
		if not index1 and index2 then return false end
	end
	
	if enchantment1 and not enchantment2 then return true end
	if not enchantment1 and enchantment2 then return false end
	
	return SortFunctions.Distance(a, b)
end

local function GetTarget()
	local npcs = {}

	for _, npc in pairs (workspace:WaitForChild("NPCS"):GetChildren()) do
		if Me:DistanceFromCharacter(npc.Position) > Settings.MaxDistance then continue end

		local humanoid = npc:FindFirstChild("Humanoid", true)
		if not string.find(npc.Name, "Snoeman") and humanoid and humanoid.Health <= 0 then continue end

		local found = false
		if #Settings.Whitelist == 0 then
			found = true
		else
			for _, white in pairs (Settings.Whitelist) do
				if string.find(string.lower(npc.Name), string.lower(white)) then
					found = true
					break
				end
			end

			for _, special in pairs (Settings.Enchantments) do
				local particle = npc:FindFirstChild(special)
				if particle and particle.Enabled then
					found = true
					break
				end
			end
		end

		if found then
			table.insert(npcs, npc)
		end
	end
	
	table.sort(npcs, SortFunctions[Settings.SortMode])
	
	return npcs[1]
end

local function FlyTo(bodyVelocity, target)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)

	while bodyVelocity.Parent and IsRunning and target.Parent do
		RunService.Stepped:Wait()

		bodyVelocity.Velocity = (bodyVelocity.Parent.Position - target.Position).Unit * -50

		local distance = Me:DistanceFromCharacter(target.Position)
		if distance <= 5 then break end
	end

	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
end

local function Heal(bodyVelocity)
	local responsesFrame = Me.PlayerGui.Core.Chatbox.Responses
	
	local inns = {}
	for _, innName in pairs (Inns) do
		local npc = workspace.Interactables:FindFirstChild(innName)
		if not npc then continue end
		if not npc:FindFirstChild("Dialog") then continue end
		
		table.insert(inns, npc)
	end
	
	table.sort(inns, function(a, b)
		return Me:DistanceFromCharacter(a.Position) < Me:DistanceFromCharacter(b.Position)
	end)
	local npc = inns[1]
	
	FlyTo(bodyVelocity, npc)
	--InitiateDialog(npc.Dialog:GetAttributes().Dialog, npc)
	
	if IsRunning then
		Camera.CameraType = Enum.CameraType.Scriptable
		Camera.CFrame = CFrame.new(Camera.CFrame.Position, npc.Position)
		RunService.RenderStepped:Wait()
		Camera.CameraType = Enum.CameraType.Custom
		
		wait(0.25)
		
		VirtualInputService:SendKeyEvent(true, Enum.KeyCode.E, false, nil)
		RunService.Stepped:Wait()
		VirtualInputService:SendKeyEvent(false, Enum.KeyCode.E, false, nil)
		
		while #responsesFrame:GetChildren() < 4 do
			RunService.Stepped:Wait()
		end
		
		for _, button in pairs (responsesFrame:GetChildren()) do
			local label = button:WaitForChild("Text2")
			if label and string.find(label.Text, "Heal") then
				ClickButton(button)
				break
			end
		end
		
		while not responsesFrame.Parent.C.Visible do
			RunService.Stepped:Wait()
		end
		
		ClickButton(responsesFrame.Parent.C)
	end
end

local function CalculateHeight(npc)
	return npc.Position + Vector3.new(0, Settings.Height, 0)
end

local function AdjustRotation(root, bodyAngular)
	bodyAngular.AngularVelocity = Vector3.new(0, 2, 0)
	while root.Rotation.Y > 2 or root.Rotation.Y < -2 do
		RunService.Stepped:Wait()
	end

	bodyAngular.AngularVelocity = Vector3.new(-2, 0, 0)
	while root.Rotation.X > -88 or root.Rotation.X < -92 do
		RunService.Stepped:Wait()
	end
	bodyAngular.AngularVelocity = Vector3.new(0, 0, 0)
end

local function Evade(duration)
	local last = tick()
	IsEvading = true
	LastEvade = last

	wait(duration)

	if LastEvade == last then
		IsEvading = false
	end
end

local function OnNPC(npc)
	wait(1)

	local linkedModel = npc:FindFirstChild("LinkedModel")
	if not linkedModel then return end

	local animator = linkedModel:WaitForChild("Humanoid"):WaitForChild("Animator")

	task.spawn(function()
		local animationsFolder = npc:WaitForChild("Animations")
		ContentProvider:PreloadAsync(animationsFolder:GetChildren())
	end)

	animator.AnimationPlayed:Connect(function(track)
		if not IsRunning or not Settings.Evade then return end
		if Me:DistanceFromCharacter(npc.Position) >= 30 then return end
		if table.find(SafeAnimations, track.Name) then return end

		if Terminus.Debug then
			print("Evading", npc.Name, track.Name)
		end

		Evade(track.Length * track.Speed)
	end)

	if string.find(string.lower(npc.Name), "bomber") then
		npc.ChildAdded:Connect(function(child)
			wait(0.5)
			if child.ClassName == "Sound" and child.Name == "Bomber" then
				Evade(5)
			end
		end)
	end
end

local function OnCharacter(character)
	wait(1)

	local root = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")
	local torso = character:WaitForChild("Torso", 1) or character:WaitForChild("UpperTorso", 1)
	local head = character:WaitForChild("Head")

	for _, part in pairs (character:GetChildren()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
		end
	end

	local attachment = Instance.new("Part", Camera)
	attachment.Name = "MOVER"
	attachment.Size = Vector3.new(0.2, 0.2, 0.2)
	attachment.CanCollide = false
	attachment.CFrame = root.CFrame
	attachment.Transparency = 1

	local weld = Instance.new("Weld", attachment)
	weld.Part0 = attachment
	weld.Part1 = root
	weld.Enabled = true

	local bodyPosition = Instance.new("BodyPosition")
	bodyPosition.Name = "BPOSITION"
	bodyPosition.D = 500
	bodyPosition.Position = attachment.Position
	bodyPosition.MaxForce = Vector3.new(0, 0, 0)
	bodyPosition.Parent = attachment

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Name = "BVEL"
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.MaxForce = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = attachment

	local bodyAngular = Instance.new("BodyAngularVelocity")
	bodyAngular.Name = "BVELA"
	bodyAngular.AngularVelocity = Vector3.new(0, 0, 0)
	bodyAngular.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
	bodyAngular.Parent = attachment
	
	local weaponSlot, runeSlot = nil
	
	if not RunService:IsStudio() then
		weaponSlot = Me.PlayerGui:WaitForChild("Core"):WaitForChild("MainBar"):WaitForChild("WeaponArt"):WaitForChild("Cooldown")
		runeSlot = Me.PlayerGui:WaitForChild("Core"):WaitForChild("MainBar"):WaitForChild("Rune"):WaitForChild("Cooldown")
	end

	local collisionSignal = nil
	collisionSignal = RunService.Stepped:Connect(function()
		if not head.Parent or not torso.Parent or not attachment.Parent then
			collisionSignal:Disconnect()
			return
		end

		torso.CanCollide = false
		head.CanCollide = false
	end)

	root.ChildAdded:Connect(function(child)
		if not IsRunning then return end

		if child.ClassName == "BodyVelocity" then
			child.MaxForce = Vector3.new(0, 0, 0)
		end
	end)

	character.AncestryChanged:Connect(function(_, parent)
		if not parent then
			attachment:Destroy()
		end
	end)
	
	if not RunService:IsStudio() and not character:FindFirstChild("Sword") then
		VirtualInputService:SendKeyEvent(true, Enum.KeyCode.One, false, nil)
		wait(0.1)
		VirtualInputService:SendKeyEvent(false, Enum.KeyCode.One, false, nil)
	end

	local function loop()
		bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		bodyVelocity.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bodyPosition.MaxForce = Vector3.new(0, 0, 0)
		
		VirtualInputService:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
		
		if Settings.HealAtInn and humanoid.Health / humanoid.MaxHealth < 0.5 then
			Heal(bodyVelocity)
		end
		
		local target = GetTarget()
		if not target then
			wait(0.5)

			if Terminus.Debug then
				print("Waiting for target")
			end

			return
		end
		local distance = Me:DistanceFromCharacter(target.Position)

		if Terminus.Debug then
			print("NPC:", target.Name, "Distance:", distance)
		end
		
		if RunService:IsStudio() then wait(0.5) return end
		
		bodyPosition.MaxForce = Vector3.new(0, 0, 0)
		bodyVelocity.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)

		--Move towards while blocking
		local targetPosition = CalculateHeight(target)
		while target.Parent and character.Parent and attachment.Parent and IsRunning do
			RunService.Stepped:Wait()

			targetPosition = CalculateHeight(target)
			if string.find(target.Name, "Snoeman") then targetPosition = target.Position end
			bodyVelocity.Velocity = (root.Position - targetPosition).Unit * -50
			
			VirtualInputService:SendKeyEvent(true, Enum.KeyCode.F, false, nil)

			local distance = Me:DistanceFromCharacter(targetPosition)
			if distance <= 5 then break end
		end
		if not target.Parent or not character.Parent or not IsRunning then return end

		bodyVelocity.MaxForce = Vector3.new(0, 0, 0)
		bodyPosition.Position = root.Position + Vector3.new(0, Settings.EvadeHeight, 0)
		bodyPosition.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)

		--Stay above and kill
		
		VirtualInputService:SendKeyEvent(false, Enum.KeyCode.F, false, nil)

		task.spawn(function()
			AdjustRotation(root, bodyAngular)
		end)

		local startAttacking = tick()
		while target.Parent and character.Parent and attachment.Parent and IsRunning do
			RunService.Stepped:Wait()

			local targetPosition = CalculateHeight(target)
			if IsEvading then
				if Settings.BlockOnEvade then
					VirtualInputService:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
				end
				if string.find(target.Name, "SteamGolem") then
					bodyPosition.Position = targetPosition + Vector3.new(Settings.EvadeHeight, Settings.EvadeHeight, Settings.EvadeHeight)
				else
					bodyPosition.Position = targetPosition + Vector3.new(0, Settings.EvadeHeight, 0)
				end

			else
				if Settings.BlockOnEvade then
					VirtualInputService:SendKeyEvent(false, Enum.KeyCode.F, false, nil)
				end
				bodyPosition.Position = targetPosition
			end

			if tick() - startAttacking > 25 then
				bodyPosition.Position = targetPosition + Vector3.new(0, Settings.EvadeHeight, 0)
				startAttacking = tick()

				task.spawn(function()
					AdjustRotation(root, bodyAngular)
				end)
			end

			if Settings.AutoAttack == false or Terminal:IsMouseOnTop() then continue end

			if Settings.UseArt and weaponSlot.Visible == false then
				VirtualInputService:SendKeyEvent(true, Enum.KeyCode.Q, false, nil)
				wait(0.1)
				VirtualInputService:SendKeyEvent(false, Enum.KeyCode.Q, false, nil)
			elseif Settings.UseRune and runeSlot.Visible == false then
				VirtualInputService:SendKeyEvent(true, Enum.KeyCode.R, false, nil)
				wait(0.1)
				VirtualInputService:SendKeyEvent(false, Enum.KeyCode.R, false, nil)
			elseif Settings.UseWeapon then
				VirtualInputService:SendMouseButtonEvent(100, 100, 0, true, game, 0)
				wait(0.05)
				VirtualInputService:SendMouseButtonEvent(100, 100, 0, false, game, 0)
			end
		end
	end

	while character.Parent and attachment.Parent and IsRunning do
		RunService.Stepped:Wait()

		local bool, arg = pcall(function()
			loop()
		end)
		if not bool then
			if Terminus.Debug then
				warn(arg)
			end
			wait(0.5)
		end

		RunService.Stepped:Wait()
	end
	
	attachment:Destroy()
end

Terminal:CreateTextLabel(nil, {
	Text = "Voxlblade Autofarm"
})

Terminal:CreateLine(nil)

Terminal:CreateTextLabel(nil, {
	Text = "TARGETING"
})

Terminal:CreateDropdown(nil, {
	Items = GetAllEnemies(),
	Selected = Settings.Whitelist,
	Padding = 2,
	MaxDisplay = 300,
	CloseOnSelect = false,
	MultiSelect = true,
	Title = #Settings.Whitelist == 0 and "Filter, none selected = all" or table.concat(Settings.Whitelist, ","),
	OnSelected = function(self, item)
		self.Title = #self.Selected == 0 and "Filter, none selected = all" or table.concat(self.Selected, ",")
	end,
})

Terminal:CreateDropdown(nil, {
	Items = Enchantments,
	Selected = Settings.Enchantments,
	Padding = 2,
	MaxDisplay = 1000,
	CloseOnSelect = false,
	MultiSelect = true,
	Title = "Enchantments to include",
	OnSelected = function(self, item)
		
	end,
	
	ItemBuilder = function(dropdown, item)
		return Terminal:CreateRow(nil, {
			Size = UDim2.new(1, 0, 0, 20),
			Items = {
				Terminal:CreateTextLabel(nil, {
					Text = item,
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
				}),
				Terminal:CreateSwitch(nil, {
					Style = SwitchStyle,
					State = dropdown:IsSelected(item),
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Height = 16,
					OnChanged = function(switch, state)
						dropdown:Select(item)
						switch.State = dropdown:IsSelected(item)
						switch:SetState()
					end,
				})
			}
		})
	end,
})

Terminal:CreateDropdown(nil, {
	Items = SortModes,
	Selected = {Settings.SortMode},
	Padding = 2,
	MaxDisplay = 1000,
	CloseOnSelect = true,
	MultiSelect = false,
	Title = "Sort mode: " .. Settings.SortMode,
	
	OnSelected = function(self, item)
		Settings.SortMode = item
		self.Title = "Sort mode: " .. Settings.SortMode
	end,
})

local HeightLabel = Terminal:CreateTextLabel(nil, {
	Text = "Height above enemy " .. tostring(Settings.Height) 
})

Terminal:CreateSlider(nil, {
	Minimum = 0,
	Maximum = 20,
	Value = Settings.Height,
	Size = UDim2.new(1, -20, 0, 20),
	
	OnChanged = function(self, value)
		Settings.Height = value
		HeightLabel.Text = "Height above enemy " .. tostring(value)
	end,
})

--EVASION-------------------------------------------------------------------------------------------------------------------------

Terminal:CreateLine()

Terminal:CreateTextLabel(nil, {
	Text = "EVADING"
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Evade attacks"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.Evade,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.Evade = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Block when evading"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.BlockOnEvade,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.BlockOnEvade = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Style = MyStyle,
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Evade height"
		}),
		Terminal:CreateTextField(nil, {
			Text = tostring(Settings.EvadeHeight),
			NumbersOnly = true,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, value)
				if not value then return end
				Settings.EvadeHeight = tonumber(value)
			end,
		})
	}
})

Terminal:CreateLine()

Terminal:CreateTextLabel(nil, {
	Text = "ATTACKING"
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Auto attack"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.AutoAttack,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.AutoAttack = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Use Weapon"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.UseWeapon,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.UseWeapon = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Use Art"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.UseArt,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.UseArt = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Text = "Use Rune"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.UseRune,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.UseRune = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 20),
	Items = {
		Terminal:CreateTextLabel(nil, {
			Style = MyStyle,
			Text = "Heal below 50%"
		}),
		Terminal:CreateSwitch(nil, {
			Height = 16,
			Style = SwitchStyle,
			State = Settings.HealAtInn,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Settings.HealAtInn = state
			end,
		})
	}
})


Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 24),
	Items = {
		Terminal:CreateTextLabel(nil, {
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			Text = "Debug"
		}),
		Terminal:CreateSwitch(nil, {
			Style = SwitchStyle,
			Height = 16,
			State = Terminus.Debug,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			OnChanged = function(self, state)
				Terminus.Debug = state
			end,
		})
	}
})

Terminal:CreateRow(nil, {
	Layout = {0.5, 0.5},
	Size = UDim2.new(1, 0, 0, 24),
	Items = {
		Terminal:CreateTextButton(nil, {
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			Size = UDim2.new(1, 0, 0, 24),
			
			Text = "Save preset",
			Selectable = false,
			OnActivated = function(self, state)
				Terminal:ExportSettings(Settings)
				Terminal:CreateNotice({
					Size = UDim2.new(0.8, 0, 0, 150),
					Title = "Presets saved",
					Body = "Saved to workspace\\Terminus\\" .. Terminal.Name .. "\\Settings.json",
					Dismissable = true
				})
			end,
		}),
		
		Terminal:CreateTextButton(nil, {
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			Size = UDim2.new(1, 0, 0, 24),
			
			Text = IsRunning and "Stop" or "Start",
			Selectable = true,
			OnSelected = function(self, state)
				IsRunning = state
				self.Text = state and "Stop" or "Start"
				
				if Me.Character then
					if IsRunning then
						OnCharacter(Me.Character)
					end
				end
			end,
		})
	}
})

if RunService:IsStudio() then return end

table.insert(Connections, Me.Idled:Connect(function()
	if not IsRunning then return end

	VirtualUserService:CaptureController()
	RunService.Stepped:Wait()
	VirtualUserService:ClickButton2(Vector2.new(0, 0))
end))

table.insert(Connections, Me.CharacterAdded:Connect(function(character)
	if not IsRunning then return end

	OnCharacter(character)
end))

table.insert(Connections, workspace:WaitForChild("NPCS").ChildAdded:Connect(OnNPC))

for _, npc in pairs (workspace:WaitForChild("NPCS"):GetChildren()) do
	task.spawn(function()
		OnNPC(npc)
	end)
end
