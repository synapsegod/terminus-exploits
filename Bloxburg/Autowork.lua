local PathfindingService = game:GetService("PathfindingService")
local VirtualUserService = game:GetService("VirtualUser")
local VirtualInputService = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local PlayerService = game:GetService("Players")
local Me = PlayerService.LocalPlayer
local Camera = workspace.CurrentCamera

local Terminus = shared.Terminus or loadstring(game:HttpGet("https://raw.githubusercontent.com/synapsegod/terminus/main/main.lua"))()
local Style = Terminus:newStyle({
	ActiveColor = Color3.fromRGB(0, 170, 255),
})
local SwitchStyle = Style:Clone({
	BackgroundColor = Color3.fromRGB(50, 50, 50)
})
local Terminal = Terminus:new("BloxburgJobs")


local MainGui = Me.PlayerGui:WaitForChild("MainGUI")
local JobMenu = MainGui:WaitForChild("Bar"):WaitForChild("CharMenu"):WaitForChild("WorkFrame")
local EquipmentFrame = MainGui:WaitForChild("EquipmentFrame")

--UI VARIABLES
--STATIC
local Jobs = {
	"BloxyBurgerCashier",
	"LumberWoodcutter",
	"PizzaPlanetBaker",
	"MikesMechanic",
	"CaveMiner",
	"PizzaPlanetDelivery",
	"BensIceCreamSeller",
	"SupermarketCashier",
	"SupermarketStocker",
	"CleanJanitor",
	"StylezHairdresser",
	"HutFisherman"
}

local Connections = {}
local CurrentJob = nil
local Running = false

function Terminal:OnClose()
	Running = false

	for _, connection in pairs (Connections) do
		connection:Disconnect()
	end
end


local function ClickButton(button)
	local position = button.AbsolutePosition
	local size = button.AbsoluteSize
	local center = position + (size / 2)
	
	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, true, game, 0)
	RunService.Stepped:Wait()
	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, false, game, 0)
end

local function PressButton(keycode, duration)
	VirtualInputService:SendKeyEvent(true, keycode, false, nil)
	wait(duration or 0.1)
	VirtualInputService:SendKeyEvent(false, keycode, false, nil)
end

local function GotoJob(name)
	local scroll = JobMenu:WaitForChild("NoWorkFrame"):WaitForChild("ScrollFrame")
	local jobButton = scroll:FindFirstChild(name .. "_Box"):WaitForChild("GoTo")
	
	getconnections(jobButton.Activated)[1].Function()
end

function LookAt(position)
	Camera.CameraType = Enum.CameraType.Scriptable
	Camera.CFrame = CFrame.new(Camera.CFrame.Position, position)
	RunService.RenderStepped:Wait()
	Camera.CameraType = Enum.CameraType.Custom
	wait(0.2)
end

local function MoveTo(position)
	local character = Me.Character
	
	assert(character, "No character")
	local path = PathfindingService:CreatePath({AgentCanJump = false, WaypointSpacing = 2})
	local humanoid = character:WaitForChild("Humanoid")
	
	-- Compute the path
	local success, errorMessage = pcall(function()
		path:ComputeAsync(character.PrimaryPart.Position, position)
	end)
	
	assert(success and path.Status == Enum.PathStatus.Success, "Failed to compute path")

	local waypoints = path:GetWaypoints()
	for _, point in pairs (waypoints) do
		humanoid:MoveTo(point.Position)
		humanoid.MoveToFinished:Wait()
	end
end

function UseEquipment()
	ClickButton(EquipmentFrame:WaitForChild("Background"))
end

local JobStuff = {
	HutFisherman = {
		Start = function(self)
			local toolLabel = EquipmentFrame:WaitForChild("ActionLabel")
			local character = Me.Character
			local tool = character:FindFirstChild("Fishing Rod")
			if not tool then
				GotoJob("HutFisherman")
				tool = character:WaitForChild("Fishing Rod")
			end

			local bopper = tool:WaitForChild("Pos")

			MoveTo(Vector3.new(1027, 13.6, 1068))
			MoveTo(Vector3.new(1021, 13.6, 1085))

			while Running and character.Parent and tool.Parent do

				UseEquipment()

				while Running and toolLabel.Text ~= "Pull" do
					RunService.Stepped:Wait()
				end
				if not Running or not tool.Parent then return end

				bopper.Changed:Wait()
				if not Running or not tool.Parent  then return end

				--incase they EVER track average times that i reel the rod
				task.wait(math.random(2, 10) / 10)

				UseEquipment()

				while Running and toolLabel.Text ~= "Cast" do
					RunService.Stepped:Wait()
				end
				if not Running or not tool.Parent  then return end
			end
		end,
	},
	BloxyBurgerCashier = {},
	LumberWoodcutter = {},
	PizzaPlanetBaker = {},
	MikesMechanic = {},
	CaveMiner = {},
	PizzaPlanetDelivery = {
		Start = function(self)
			local mountainSide = Vector3.new(1931.02, 13.8601, 325.493)
			local riverSide = Vector3.new(-139.447, 25.7603, 323.166)
			local character = Me.Character
			assert(character, "No character")
			
			local arrowContainer = workspace:WaitForChild("MouseIgnore")
			local npcContainer = workspace:WaitForChild("_game"):WaitForChild("SpawnedCharacters")
			local pickupSpot = Vector3.new(1168.47, 12.8037, 274.431)
			local pizzaCenter = Vector3.new(1168.68, 12.756, 268.6)
			
			GotoJob("PizzaPlanetDelivery")
			MoveTo(Vector3.new(1169.82, 13.6577, 275.861)) --infront pizzas
			LookAt(pizzaCenter) --pizza2
			PressButton(Enum.KeyCode.E)
			while not character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
			MoveTo(Vector3.new(1175.26, 13.6777, 289.284)) --infront bike
			LookAt(Vector3.new(1175.83, 13.0497, 283.901)) --bike
			PressButton(Enum.KeyCode.E)
			
			local moped = character:WaitForChild("Vehicle_Delivery Moped")
			local engine = moped:WaitForChild("Body")
			local oldVel = engine:WaitForChild("BodyVelocity")
			local oldGyro = engine:WaitForChild("BodyGyro")
			
			local attachment = Instance.new("Part", moped)
			attachment.Name = "Fake"
			attachment.Size = Vector3.new(1, 1, 1)
			attachment.CanCollide = false
			attachment.CFrame = engine.CFrame
			attachment.Transparency = 1

			local weld = Instance.new("Weld", attachment)
			weld.Part0 = attachment
			weld.Part1 = engine
			weld.Enabled = true

			local bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "BVEL"
			bodyVelocity.P = 4000
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			bodyVelocity.MaxForce = oldVel.MaxForce + Vector3.new(100000, 1000000000, 100000)
			bodyVelocity.Parent = attachment

			local bodyGyro = Instance.new("BodyGyro")
			bodyGyro.Name = "BGYRO"
			bodyGyro.MaxTorque = oldGyro.MaxTorque + Vector3.new(100000, 100000, 100000)
			bodyGyro.D = 500
			bodyGyro.P = 4000
			bodyGyro.Parent = attachment
			
			wait(1)
			
			local function moveMoped(target)
				local distance = (engine.Position - target).Magnitude
				local duration = distance / 30
				
				bodyVelocity.Velocity = (engine.Position - target).Unit * -30
				bodyGyro.CFrame = CFrame.new(engine.Position, target)
				
				wait(duration)
				
				bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			end
			
			local signal = nil
			signal = RunService.Stepped:Connect(function()
				for _, part in pairs (character:GetChildren()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
						
					end
				end
				
				for _, part in pairs (moped:GetChildren()) do
					if part:IsA("BasePart") then part.CanCollide = false end
				end
			end)
			
			Me.CameraMaxZoomDistance = 5
			
			while Running and character.Parent and moped.Parent do
				local arrow = arrowContainer:WaitForChild("DeliveryArrow")
				
				local customer = npcContainer:FindFirstChild("PizzaPlanetDeliveryCustomer")
				while not customer and Running do
					--follow arrow direction until customer loads
					moveMoped((arrow.CFrame * CFrame.new(0, 0, -30)).Position)
					if not Running then break end
					customer = npcContainer:FindFirstChild("PizzaPlanetDeliveryCustomer")
					RunService.Stepped:Wait()
				end
				if not Running then break end
				
				local root = customer:WaitForChild("HumanoidRootPart")
				
				moveMoped((root.CFrame).Position)
				LookAt(root.Position)
				PressButton(Enum.KeyCode.E)
				while character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
				moveMoped(pickupSpot)
				LookAt(pizzaCenter)
				PressButton(Enum.KeyCode.E)
				while not character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
				
				RunService.Stepped:Wait()
			end
			
			Me.CameraMaxZoomDistance = 100
			signal:Disconnect()
		end,	
	},
	BensIceCreamSeller = {},
	SupermarketCashier = {},
	SupermarketStocker = {},
	CleanJanitor = {},
	StylezHairdresser = {},
}

local Scroll = Instance.new("ScrollingFrame")
Scroll.BackgroundTransparency = 1
Scroll.Size = UDim2.new(1, 0, 1, 0)
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.ScrollBarThickness = 4
Scroll.Parent = Terminal.Instance

local Sorter = Instance.new("UIListLayout", Scroll)
Sorter.SortOrder = Enum.SortOrder.LayoutOrder
Sorter.FillDirection = Enum.FillDirection.Vertical
Sorter.HorizontalAlignment = Enum.HorizontalAlignment.Center
Sorter.VerticalAlignment = Enum.VerticalAlignment.Top
Sorter.Padding = UDim.new(0, 5)

Terminal:CreateTextLabel(Scroll, {Text = "Bloxburg Autowork"})
Terminal:CreateLine(Scroll, {
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateDropdown(Scroll, {
	Size = UDim2.new(1, -4, 0, 20),
	Items = Jobs,
	Padding = 2,
	MaxDisplay = #Jobs * 20,
	CloseOnSelect = true,
	MultiSelect = false,
	Title = "Select a job",
	OnSelected = function(self, job)
		CurrentJob = job
		self.Title = job
	end,
})

Terminal:CreateTextButton(Scroll, {
	Text = Running and "Stop" or "Start",
	Selectable = true,
	OnSelected = function(self, state)
		if state and not CurrentJob then
			Terminal:CreateNotice({
				Title = "Error",
				Body = "No job selected"
			})
			self:Toggle(false)
			
			return
		end

		Running = state
		self.Text = state and "Stop" or "Start"

		if Running then
			local bool, arg = pcall(function()
				JobStuff[CurrentJob]:Start()
			end)
			if not bool then
				warn(arg)
				
				Terminal:CreateNotice({
					Title = "Error",
					Body = arg
				})
			end
		end
	end,
})

Scroll.CanvasSize = UDim2.new(0, Sorter.AbsoluteContentSize.X, 0, Sorter.AbsoluteContentSize.Y)

table.insert(Connections, Me.Idled:Connect(function()
	if not Running then return end

	VirtualUserService:CaptureController()
	RunService.Stepped:Wait()
	VirtualUserService:ClickButton2(Vector2.new(0, 0))
end))
