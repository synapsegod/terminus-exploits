local PathfindingService = game:GetService("PathfindingService")
local VirtualUserService = game:GetService("VirtualUser")
local VirtualInputService = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local PlayerService = game:GetService("Players")
local Me = PlayerService.LocalPlayer
local Camera = workspace.CurrentCamera

local Terminus = shared.Terminus or loadstring(game:HttpGet("https://raw.githubusercontent.com/synapsegod/terminus/main/main.lua"))()
local Style = Terminus:newStyle({
	ActiveColor = Color3.fromRGB(0, 170, 255),
})
local SwitchStyle = Style:Clone({
	BackgroundColor = Color3.fromRGB(50, 50, 50)
})
local Terminal = Terminus:new("BloxburgJobs")


local MainGui = Me.PlayerGui:WaitForChild("MainGUI")
local JobMenu = MainGui:WaitForChild("Bar"):WaitForChild("CharMenu"):WaitForChild("WorkFrame")
local EquipmentFrame = MainGui:WaitForChild("EquipmentFrame")
local InteractionMenu = MainGui:WaitForChild("InteractionMenu")

--UI VARIABLES
--STATIC
local Jobs = {
	"BloxyBurgerCashier",
	"LumberWoodcutter",
	"PizzaPlanetBaker",
	"MikesMechanic",
	"CaveMiner",
	"PizzaPlanetDelivery",
	"BensIceCreamSeller",
	"SupermarketCashier",
	"SupermarketStocker",
	"CleanJanitor",
	"StylezHairdresser",
	"HutFisherman"
}

local Connections = {}
local CurrentJob = nil
local Running = false

function Terminal:OnClose()
	Running = false

	for _, connection in pairs (Connections) do
		connection:Disconnect()
	end
end

local function ClickButton(button)
	local position = button.AbsolutePosition
	local size = button.AbsoluteSize
	local center = position + (size / 2)
	
	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, true, game, 0)
	RunService.Stepped:Wait()
	VirtualInputService:SendMouseButtonEvent(center.X, center.Y, 0, false, game, 0)
end

local function ClickInteract(worldPosition)
	LookAt(worldPosition)
	local position, isVisible = Camera:WorldToScreenPoint(worldPosition)
	--isVisible should be true
	
	VirtualInputService:SendMouseButtonEvent(position.X, position.Y, 0, true, game, 0)
	RunService.Stepped:Wait()
	VirtualInputService:SendMouseButtonEvent(position.X, position.Y, 0, false, game, 0)
	wait(0.4)
end

local function ClickInteractionMenu(interactionText)
	for _, interaction in pairs (InteractionMenu:WaitForChild("Center"):GetChildren()) do
		if interaction.Name == "Button" then
			if interaction:WaitForChild("TextLabel").Text == interactionText then
				getconnections(interaction.Activated)[1]:Fire()
			end
		end
	end
end

local function PressButton(keycode, duration)
	VirtualInputService:SendKeyEvent(true, keycode, false, nil)
	wait(duration or 0.1)
	VirtualInputService:SendKeyEvent(false, keycode, false, nil)
end

local function GotoJob(name)
	local scroll = JobMenu:WaitForChild("NoWorkFrame"):WaitForChild("ScrollFrame")
	local jobButton = scroll:FindFirstChild(name .. "_Box"):WaitForChild("GoTo")
	
	getconnections(jobButton.Activated)[1].Function()
end

function LookAt(position)
	Camera.CameraType = Enum.CameraType.Scriptable
	Camera.CFrame = CFrame.new(Camera.CFrame.Position, position)
	RunService.RenderStepped:Wait()
	Camera.CameraType = Enum.CameraType.Custom
	wait(0.2)
end

local function MoveTo(position)
	local character = Me.Character
	
	assert(character, "No character")
	local path = PathfindingService:CreatePath({AgentCanJump = false, WaypointSpacing = 2})
	local humanoid = character:WaitForChild("Humanoid")
	
	-- Compute the path
	local success, errorMessage = pcall(function()
		path:ComputeAsync(character.PrimaryPart.Position, position)
	end)
	
	assert(success and path.Status == Enum.PathStatus.Success, "Failed to compute path")

	local waypoints = path:GetWaypoints()
	for _, point in pairs (waypoints) do
		humanoid:MoveTo(point.Position)
		humanoid.MoveToFinished:Wait()
	end
end

local function HasEquipment()
	return EquipmentFrame.Visible
end

local function UseEquipment()
	ClickButton(EquipmentFrame:WaitForChild("Background"))
end

local JobStuff = {
	HutFisherman = {
		Start = function(self)
			local toolLabel = EquipmentFrame:WaitForChild("ActionLabel")
			local character = Me.Character
			local tool = character:FindFirstChild("Fishing Rod")
			if not tool then
				GotoJob("HutFisherman")
				tool = character:WaitForChild("Fishing Rod")
			end

			local bopper = tool:WaitForChild("Pos")

			MoveTo(Vector3.new(1027, 13.6, 1068))
			MoveTo(Vector3.new(1021, 13.6, 1085))

			while Running and character.Parent and tool.Parent do

				UseEquipment()

				while Running and toolLabel.Text ~= "Pull" do
					RunService.Stepped:Wait()
				end
				if not Running or not tool.Parent then return end

				bopper.Changed:Wait()
				if not Running or not tool.Parent  then return end

				--incase they EVER track average times that i reel the rod
				task.wait(math.random(2, 10) / 10)

				UseEquipment()

				while Running and toolLabel.Text ~= "Cast" do
					RunService.Stepped:Wait()
				end
				if not Running or not tool.Parent  then return end
			end
		end,
	},
	BloxyBurgerCashier = {},
	LumberWoodcutter = {},
	PizzaPlanetBaker = {},
	MikesMechanic = {
		Start = function(self)
			local character = Me.Character
			assert(character, "No character")
			
			GotoJob("MikesMechanic")
			
			local stand = Vector3.new(1161.3, 13.6, 402.2)
			local bikeInteraction = Vector3.new(1167.41, 12.2, 402.283)
			
			local model = workspace:WaitForChild("Environment"):WaitForChild("Locations"):WaitForChild("MikesMotors")
			local tiresModel = model:WaitForChild("TireRacks")
			local colorsModel = model:WaitForChild("PaintingEquipment")
			
			local positions = {
				Wheels = {
					Moped = {
						WalkTo = Vector3.new(1156.9, 13.6, 402.7),
						Interaction = tiresModel:WaitForChild("Moped"):WaitForChild("Origin").Position
					},
					Bloxster = {
						WalkTo = Vector3.new(1157.3, 13.6, 410),
						Interaction = tiresModel:WaitForChild("Bloxster"):WaitForChild("Origin").Position
					},
					Classic = {
						WalkTo = Vector3.new(1157.9, 13.6, 397),
						Interaction = tiresModel:WaitForChild("Classic"):WaitForChild("Origin").Position
					}
				},
				Oil = {
					WalkTo = Vector3.new(1194.5, 13.6, 390),
					Interaction = model:WaitForChild("OilCans"):WaitForChild("Can"):WaitForChild("Body").Position
				},
				Color = {
					Green = {
						WalkTo = Vector3.new(1175, 13.6, 390),
						Interaction = colorsModel:WaitForChild("Green"):WaitForChild("Handle").Position
					},
					Black = {
						WalkTo = Vector3.new(1175, 13.6, 390),
						Interaction = colorsModel:WaitForChild("Black"):WaitForChild("Handle").Position
					},
					Purple = {
						WalkTo = Vector3.new(1175, 13.6, 390),
						Interaction = colorsModel:WaitForChild("Purple"):WaitForChild("Handle").Position
					},
					Red = {
						WalkTo = Vector3.new(1175, 13.6, 390),
						Interaction = colorsModel:WaitForChild("Red"):WaitForChild("Handle").Position
					}
					
				}
			}
			
			local function getOrder()
				for _, customer in pairs (workspace:WaitForChild("_game"):WaitForChild("SpawnedCharacters"):GetChildren()) do
					if customer.Name ~= "MikesMotorsCustomer" then continue end
					
					local order = customer:FindFirstChild("Order")
					if not order then continue end
					
					return order
				end
			end
			
			local function pressDone()
				for _, station in pairs (model:WaitForChild("MechanicWorkstations"):GetChildren()) do
					if station:WaitForChild("InUse").Value == Me then
						local mechanicGui = station:WaitForChild("Display"):WaitForChild("Screen"):WaitForChild("MechanicGUI")
						local button = mechanicGui:WaitForChild("Frame"):WaitForChild("Done")
						getconnections(button.Activated)[1]:Fire()
					end
				end
			end
			
			Me.CameraMaxZoomDistance = 4
			
			MoveTo(stand)
			LookAt(bikeInteraction)
			
			wait(2)
			
			while Running and character.Parent do
				
				local order = getOrder()
				while not order do order = getOrder() RunService.Stepped:Wait() end
				
				if order:FindFirstChild("Wheels") then
					local wheels = order.Wheels.Value
					
					--move to wheel stand and get wheel
					MoveTo(positions.Wheels[wheels].WalkTo)
					LookAt(positions.Wheels[wheels].Interaction)
					PressButton(Enum.KeyCode.E)
					--move back to bike and change front wheel
					MoveTo(stand)
					LookAt(bikeInteraction)
					PressButton(Enum.KeyCode.E)
					wait(1)
					ClickInteractionMenu("Change Front Wheel")
					while HasEquipment() do RunService.Stepped:Wait() end
					--move to wheel stand and get wheel
					MoveTo(positions.Wheels[wheels].WalkTo)
					LookAt(positions.Wheels[wheels].Interaction)
					PressButton(Enum.KeyCode.E)
					--move back to bike and apply wheel
					MoveTo(stand)
					LookAt(bikeInteraction)
					PressButton(Enum.KeyCode.E)
					while HasEquipment() do RunService.Stepped:Wait() end
					--finish
					pressDone()
					while order.Parent do RunService.Stepped:Wait() end
				elseif order:FindFirstChild("Color") then
					local color = order.Color.Value
					
					--move to colors and get color
					MoveTo(positions.Color[color].WalkTo)
					ClickInteract(positions.Color[color].Interaction)
					wait(1)
					ClickInteractionMenu("Take")
					--move back to bike and paint
					MoveTo(stand)
					LookAt(bikeInteraction)
					PressButton(Enum.KeyCode.E)
					while HasEquipment() do RunService.Stepped:Wait() end
					--finish
					pressDone()
					while order.Parent do RunService.Stepped:Wait() end
				elseif order:FindFirstChild("Oil") then
					--move to oil and get oil
					MoveTo(positions.Oil.WalkTo)
					LookAt(positions.Oil.Interaction)
					PressButton(Enum.KeyCode.E)
					--move back to bike and apply oil
					MoveTo(stand)
					LookAt(bikeInteraction)
					PressButton(Enum.KeyCode.E)
					while HasEquipment() do RunService.Stepped:Wait() end
					--finish
					pressDone()
					while order.Parent do RunService.Stepped:Wait() end
				end
				
				wait(1)
			end
			
			Me.CameraMaxZoomDistance = 100
		end,
	},
	CaveMiner = {},
	PizzaPlanetDelivery = {
		Start = function(self)
			local character = Me.Character
			assert(character, "No character")
			
			local arrowContainer = workspace:WaitForChild("MouseIgnore")
			local npcContainer = workspace:WaitForChild("_game"):WaitForChild("SpawnedCharacters")
			
			GotoJob("PizzaPlanetDelivery")
			MoveTo(Vector3.new(1169.82, 13.6577, 275.861)) --infront pizzas
			LookAt(1168.68, 12.756, 268.6) --pizza2
			PressButton(Enum.KeyCode.E)
			while not character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
			MoveTo(Vector3.new(1175.26, 13.6777, 289.284)) --infront bike
			LookAt(Vector3.new(1175.83, 13.0497, 283.901)) --bike
			PressButton(Enum.KeyCode.E)
			
			local moped = character:WaitForChild("Vehicle_Delivery Moped")
			local engine = moped:WaitForChild("Body")
			local oldVel = engine:WaitForChild("BodyVelocity")
			local oldGyro = engine:WaitForChild("BodyGyro")
			
			local attachment = Instance.new("Part", moped)
			attachment.Name = "Fake"
			attachment.Size = Vector3.new(1, 1, 1)
			attachment.CanCollide = false
			attachment.CFrame = engine.CFrame
			attachment.Transparency = 1

			local weld = Instance.new("Weld", attachment)
			weld.Part0 = attachment
			weld.Part1 = engine
			weld.Enabled = true

			local bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "BVEL"
			bodyVelocity.P = 4000
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			bodyVelocity.MaxForce = oldVel.MaxForce + Vector3.new(100000, 1000000000, 100000)
			bodyVelocity.Parent = attachment

			local bodyGyro = Instance.new("BodyGyro")
			bodyGyro.Name = "BGYRO"
			bodyGyro.MaxTorque = oldGyro.MaxTorque + Vector3.new(100000, 100000, 100000)
			bodyGyro.D = 500
			bodyGyro.P = 4000
			bodyGyro.Parent = attachment
			
			wait(1)
			
			local function moveMoped(target)
				local distance = (engine.Position - target).Magnitude
				local duration = distance / 30
				
				bodyVelocity.Velocity = (engine.Position - target).Unit * -30
				bodyGyro.CFrame = CFrame.new(engine.Position, target)
				
				wait(duration)
				
				bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			end
			
			local signal = nil
			signal = RunService.Stepped:Connect(function()
				moped.BaseCollision.CanCollide = false
				for _, part in pairs (character:GetChildren()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
					end
				end
			end)
			
			Me.CameraMaxZoomDistance = 5
			
			while Running and character.Parent and moped.Parent do
				local arrow = arrowContainer:WaitForChild("DeliveryArrow")
				
				local customer = npcContainer:FindFirstChild("PizzaPlanetDeliveryCustomer")
				while not customer and Running and character.Parent and moped.Parent do
					--follow arrow direction until customer loads
					moveMoped((arrow.CFrame * CFrame.new(0, 0, -30)).Position)
					if not Running then break end
					customer = npcContainer:FindFirstChild("PizzaPlanetDeliveryCustomer")
					RunService.Stepped:Wait()
				end
				if not Running then break end
				
				local root = customer:WaitForChild("HumanoidRootPart")
				
				moveMoped((root.CFrame).Position)
				LookAt(root.Position)
				PressButton(Enum.KeyCode.E)
				while character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
				moveMoped(Vector3.new(1169.255, 12.8, 273.476))
				LookAt(1168.68, 12.756, 268.6)
				PressButton(Enum.KeyCode.E)
				while not character:FindFirstChild("Pizza Box") do RunService.Stepped:Wait() end
				
				RunService.Stepped:Wait()
			end
			
			Me.CameraMaxZoomDistance = 100
			signal:Disconnect()
		end,	
	},
	BensIceCreamSeller = {},
	SupermarketCashier = {},
	SupermarketStocker = {},
	CleanJanitor = {},
	StylezHairdresser = {},
}

local Scroll = Instance.new("ScrollingFrame")
Scroll.BackgroundTransparency = 1
Scroll.Size = UDim2.new(1, 0, 1, 0)
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.ScrollBarThickness = 4
Scroll.Parent = Terminal.Instance

local Sorter = Instance.new("UIListLayout", Scroll)
Sorter.SortOrder = Enum.SortOrder.LayoutOrder
Sorter.FillDirection = Enum.FillDirection.Vertical
Sorter.HorizontalAlignment = Enum.HorizontalAlignment.Center
Sorter.VerticalAlignment = Enum.VerticalAlignment.Top
Sorter.Padding = UDim.new(0, 5)

Terminal:CreateTextLabel(Scroll, {Text = "Bloxburg Autowork"})
Terminal:CreateLine(Scroll, {
	Size = UDim2.new(1, -10, 0, 1)
})

Terminal:CreateDropdown(Scroll, {
	Size = UDim2.new(1, -4, 0, 20),
	Items = Jobs,
	Padding = 2,
	MaxDisplay = #Jobs * 20,
	CloseOnSelect = true,
	MultiSelect = false,
	Title = "Select a job",
	OnSelected = function(self, job)
		CurrentJob = job
		self.Title = job
		if job == "MikesMechanic" then
			Terminal:CreateNotice({
				Title = "Notice",
				Body = "Make sure there are no customers on the bike stands"
			})
		end
	end,
})

Terminal:CreateTextButton(Scroll, {
	Text = Running and "Stop" or "Start",
	Selectable = true,
	OnSelected = function(self, state)
		if state and not CurrentJob then
			Terminal:CreateNotice({
				Title = "Error",
				Body = "No job selected"
			})
			self:Toggle(false)
			
			return
		end

		Running = state
		self.Text = state and "Stop" or "Start"

		if Running then
			local bool, arg = pcall(function()
				JobStuff[CurrentJob]:Start()
			end)
			if not bool then
				warn(arg)
				
				Terminal:CreateNotice({
					Title = "Error",
					Body = arg
				})
				Running = false
				self.Text = state and "Stop" or "Start"
				self:Toggle(false)
			end
		end
	end,
})

Scroll.CanvasSize = UDim2.new(0, Sorter.AbsoluteContentSize.X, 0, Sorter.AbsoluteContentSize.Y)

table.insert(Connections, Me.Idled:Connect(function()
	if not Running then return end

	VirtualUserService:CaptureController()
	RunService.Stepped:Wait()
	VirtualUserService:ClickButton2(Vector2.new(0, 0))
end))
